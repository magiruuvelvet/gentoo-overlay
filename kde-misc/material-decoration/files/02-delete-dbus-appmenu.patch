diff --git a/src/AppMenuButton.cc b/src/AppMenuButton.cc
deleted file mode 100644
index 7d72fcc..0000000
--- a/src/AppMenuButton.cc
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- * Copyright (C) 2020 Chris Holland <zrenfire@gmail.com>
- * Copyright (C) 2016 Kai Uwe Broulik <kde@privat.broulik.de>
- * Copyright (C) 2014 by Hugo Pereira Da Costa <hugo.pereira@free.fr>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program. If not, see <http://www.gnu.org/licenses/>.
- */
-
-// own
-#include "AppMenuButton.h"
-#include "Material.h"
-#include "Button.h"
-#include "Decoration.h"
-#include "AppMenuButtonGroup.h"
-
-// KDecoration
-#include <KDecoration2/DecoratedClient>
-
-// KF
-#include <KColorUtils>
-
-// Qt
-#include <QDebug>
-
-
-namespace Material
-{
-
-AppMenuButton::AppMenuButton(Decoration *decoration, const int buttonIndex, QObject *parent)
-    : Button(KDecoration2::DecorationButtonType::Custom, decoration, parent)
-    , m_buttonIndex(buttonIndex)
-{
-    setCheckable(true);
-
-    connect(this, &AppMenuButton::clicked,
-        this, &AppMenuButton::trigger);
-
-    const auto *buttonGroup = qobject_cast<AppMenuButtonGroup *>(parent);
-    if (buttonGroup) {
-        setOpacity(buttonGroup->opacity());
-    }
-}
-
-AppMenuButton::~AppMenuButton()
-{
-}
-
-int AppMenuButton::buttonIndex() const
-{
-    return m_buttonIndex;
-}
-
-QColor AppMenuButton::backgroundColor() const
-{
-    const auto *buttonGroup = qobject_cast<AppMenuButtonGroup *>(parent());
-    if (buttonGroup
-        && buttonGroup->isMenuOpen()
-        && buttonGroup->currentIndex() != m_buttonIndex
-    ) {
-        return Qt::transparent;
-    } else {
-        return Button::backgroundColor();
-    }
-}
-
-QColor AppMenuButton::foregroundColor() const
-{
-    const auto *buttonGroup = qobject_cast<AppMenuButtonGroup *>(parent());
-    if (buttonGroup
-        && buttonGroup->isMenuOpen()
-        && buttonGroup->currentIndex() != m_buttonIndex
-    ) {
-        const auto *deco = qobject_cast<Decoration *>(decoration());
-        if (!deco) {
-            return {};
-        }
-        return KColorUtils::mix(
-            deco->titleBarBackgroundColor(),
-            deco->titleBarForegroundColor(),
-            0.8);
-    } else {
-        return Button::foregroundColor();
-    }
-}
-
-void AppMenuButton::trigger() {
-    // qCDebug(category) << "AppMenuButton::trigger" << m_buttonIndex;
-
-    auto *buttonGroup = qobject_cast<AppMenuButtonGroup *>(parent());
-    buttonGroup->trigger(m_buttonIndex);
-}
-
-} // namespace Material
diff --git a/src/AppMenuButton.h b/src/AppMenuButton.h
deleted file mode 100644
index 8f99429..0000000
--- a/src/AppMenuButton.h
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Copyright (C) 2020 Chris Holland <zrenfire@gmail.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program. If not, see <http://www.gnu.org/licenses/>.
- */
-
-#pragma once
-
-// own
-#include "Button.h"
-
-namespace Material
-{
-
-class Decoration;
-
-class AppMenuButton : public Button
-{
-    Q_OBJECT
-
-public:
-    AppMenuButton(Decoration *decoration, const int buttonIndex, QObject *parent = nullptr);
-    ~AppMenuButton() override;
-
-    Q_PROPERTY(int buttonIndex READ buttonIndex NOTIFY buttonIndexChanged)
-
-    int buttonIndex() const;
-
-    QColor backgroundColor() const override;
-    QColor foregroundColor() const override;
-
-signals:
-    void buttonIndexChanged();
-
-public slots:
-    virtual void trigger();
-
-private:
-    int m_buttonIndex;
-};
-
-} // namespace Material
diff --git a/src/AppMenuButtonGroup.cc b/src/AppMenuButtonGroup.cc
deleted file mode 100644
index e410b16..0000000
--- a/src/AppMenuButtonGroup.cc
+++ /dev/null
@@ -1,574 +0,0 @@
-/*
- * Copyright (C) 2020 Chris Holland <zrenfire@gmail.com>
- * Copyright (C) 2016 Kai Uwe Broulik <kde@privat.broulik.de>
- * Copyright (C) 2014 by Hugo Pereira Da Costa <hugo.pereira@free.fr>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program. If not, see <http://www.gnu.org/licenses/>.
- */
-
-// own
-#include "AppMenuButtonGroup.h"
-#include "Material.h"
-#include "BuildConfig.h"
-#include "AppMenuModel.h"
-#include "Decoration.h"
-#include "AppMenuButton.h"
-#include "TextButton.h"
-#include "MenuOverflowButton.h"
-
-// KDecoration
-#include <KDecoration2/DecoratedClient>
-#include <KDecoration2/DecorationButton>
-#include <KDecoration2/DecorationButtonGroup>
-
-// KF
-#include <KWindowSystem>
-
-// Qt
-#include <QAction>
-#include <QDebug>
-#include <QMenu>
-#include <QPainter>
-#include <QVariantAnimation>
-
-
-namespace Material
-{
-
-AppMenuButtonGroup::AppMenuButtonGroup(Decoration *decoration)
-    : KDecoration2::DecorationButtonGroup(decoration)
-    , m_appMenuModel(nullptr)
-    , m_currentIndex(-1)
-    , m_overflowIndex(-1)
-    , m_hovered(false)
-    , m_showing(true)
-    , m_alwaysShow(true)
-    , m_animationEnabled(false)
-    , m_animation(new QVariantAnimation(this))
-    , m_opacity(1)
-{
-    // Assign showing and opacity before we bind the onShowingChanged animation
-    // so that new windows do not animate.
-    setAlwaysShow(decoration->menuAlwaysShow());
-    updateShowing();
-    setOpacity(m_showing ? 1 : 0);
-
-    connect(this, &AppMenuButtonGroup::showingChanged,
-            this, &AppMenuButtonGroup::onShowingChanged);
-    connect(this, &AppMenuButtonGroup::hoveredChanged,
-            this, &AppMenuButtonGroup::updateShowing);
-    connect(this, &AppMenuButtonGroup::alwaysShowChanged,
-            this, &AppMenuButtonGroup::updateShowing);
-    connect(this, &AppMenuButtonGroup::currentIndexChanged,
-            this, &AppMenuButtonGroup::updateShowing);
-
-    m_animationEnabled = decoration->animationsEnabled();
-    m_animation->setDuration(decoration->animationsDuration());
-    m_animation->setStartValue(0.0);
-    m_animation->setEndValue(1.0);
-    m_animation->setEasingCurve(QEasingCurve::InOutQuad);
-    connect(m_animation, &QVariantAnimation::valueChanged, this, [this](const QVariant &value) {
-        setOpacity(value.toReal());
-    });
-    connect(this, &AppMenuButtonGroup::opacityChanged, this, [this]() {
-        // update();
-    });
-
-    auto *decoratedClient = decoration->client().toStrongRef().data();
-    connect(decoratedClient, &KDecoration2::DecoratedClient::hasApplicationMenuChanged,
-            this, &AppMenuButtonGroup::updateAppMenuModel);
-    connect(this, &AppMenuButtonGroup::requestActivateIndex,
-            this, &AppMenuButtonGroup::trigger);
-    connect(this, &AppMenuButtonGroup::requestActivateOverflow,
-            this, &AppMenuButtonGroup::triggerOverflow);
-}
-
-AppMenuButtonGroup::~AppMenuButtonGroup()
-{
-}
-
-int AppMenuButtonGroup::currentIndex() const
-{
-    return m_currentIndex;
-}
-
-void AppMenuButtonGroup::setCurrentIndex(int set)
-{
-    if (m_currentIndex != set) {
-        m_currentIndex = set;
-        // qCDebug(category) << this << "setCurrentIndex" << m_currentIndex;
-        emit currentIndexChanged();
-    }
-}
-
-bool AppMenuButtonGroup::overflowing() const
-{
-    return m_overflowing;
-}
-
-void AppMenuButtonGroup::setOverflowing(bool set)
-{
-    if (m_overflowing != set) {
-        m_overflowing = set;
-        // qCDebug(category) << this << "setOverflowing" << m_overflowing;
-        emit overflowingChanged();
-    }
-}
-
-bool AppMenuButtonGroup::hovered() const
-{
-    return m_hovered;
-}
-
-void AppMenuButtonGroup::setHovered(bool value)
-{
-    if (m_hovered != value) {
-        m_hovered = value;
-        // qCDebug(category) << this << "setHovered" << m_hovered;
-        emit hoveredChanged(value);
-    }
-}
-
-bool AppMenuButtonGroup::showing() const
-{
-    return m_showing;
-}
-
-void AppMenuButtonGroup::setShowing(bool value)
-{
-    if (m_showing != value) {
-        m_showing = value;
-        // qCDebug(category) << this << "setShowing" << m_showing << "alwaysShow" << m_alwaysShow << "currentIndex" << m_currentIndex << "opacity" << m_opacity;
-        emit showingChanged(value);
-    }
-}
-
-bool AppMenuButtonGroup::alwaysShow() const
-{
-    return m_alwaysShow;
-}
-
-void AppMenuButtonGroup::setAlwaysShow(bool value)
-{
-    if (m_alwaysShow != value) {
-        m_alwaysShow = value;
-        // qCDebug(category) << this << "setAlwaysShow" << m_alwaysShow;
-        emit alwaysShowChanged(value);
-    }
-}
-
-bool AppMenuButtonGroup::animationEnabled() const
-{
-    return m_animationEnabled;
-}
-
-void AppMenuButtonGroup::setAnimationEnabled(bool value)
-{
-    if (m_animationEnabled != value) {
-        m_animationEnabled = value;
-        emit animationEnabledChanged(value);
-    }
-}
-
-int AppMenuButtonGroup::animationDuration() const
-{
-    return m_animation->duration();
-}
-
-void AppMenuButtonGroup::setAnimationDuration(int value)
-{
-    if (m_animation->duration() != value) {
-        m_animation->setDuration(value);
-        emit animationDurationChanged(value);
-    }
-}
-
-qreal AppMenuButtonGroup::opacity() const
-{
-    return m_opacity;
-}
-
-void AppMenuButtonGroup::setOpacity(qreal value)
-{
-    if (m_opacity != value) {
-        m_opacity = value;
-
-        for (int i = 0; i < buttons().length(); i++) {
-            KDecoration2::DecorationButton* decoButton = buttons().value(i);
-            auto *button = qobject_cast<Button *>(decoButton);
-            if (button) {
-                button->setOpacity(m_opacity);
-            }
-        }
-
-        emit opacityChanged(value);
-    }
-}
-
-KDecoration2::DecorationButton* AppMenuButtonGroup::buttonAt(int x, int y) const
-{
-    for (int i = 0; i < buttons().length(); i++) {
-        KDecoration2::DecorationButton* button = buttons().value(i);
-        if (!button->isVisible()) {
-            continue;
-        }
-        if (button->geometry().contains(x, y)) {
-            return button;
-        }
-    }
-    return nullptr;
-}
-
-void AppMenuButtonGroup::resetButtons()
-{
-    // qCDebug(category) << "    resetButtons";
-    // qCDebug(category) << "        before" << buttons();
-    auto list = QVector<QPointer<KDecoration2::DecorationButton>>(buttons());
-    // qCDebug(category) << "          list" << list;
-    removeButton(KDecoration2::DecorationButtonType::Custom);
-    // qCDebug(category) << "     remCustom" << buttons();
-    while (!list.isEmpty()) {
-        auto item = list.takeFirst();
-        // qCDebug(category) << "        delete" << item;
-        delete item;
-    }
-    // qCDebug(category) << "         after" << list;
-    emit menuUpdated();
-}
-
-void AppMenuButtonGroup::initAppMenuModel()
-{
-    m_appMenuModel = new AppMenuModel(this);
-    connect(m_appMenuModel, &AppMenuModel::modelReset,
-        this, &AppMenuButtonGroup::updateAppMenuModel);
-    // qCDebug(category) << "AppMenuModel" << m_appMenuModel;
-}
-
-void AppMenuButtonGroup::updateAppMenuModel()
-{
-    auto *deco = qobject_cast<Decoration *>(decoration());
-    if (!deco) {
-        return;
-    }
-    auto *decoratedClient = deco->client().toStrongRef().data();
-
-    // Don't display AppMenu in modal windows.
-    if (decoratedClient->isModal()) {
-        resetButtons();
-        return;
-    }
-
-    if (!decoratedClient->hasApplicationMenu()) {
-        resetButtons();
-        return;
-    }
-
-    if (m_appMenuModel) {
-        // Update AppMenuModel
-        // qCDebug(category) << "AppMenuModel" << m_appMenuModel;
-
-        resetButtons();
-
-        // Populate
-        for (int row = 0; row < m_appMenuModel->rowCount(); row++) {
-            const QModelIndex index = m_appMenuModel->index(row, 0);
-            const QString itemLabel = m_appMenuModel->data(index, AppMenuModel::MenuRole).toString();
-
-            // https://github.com/psifidotos/applet-window-appmenu/blob/908e60831d7d68ee56a56f9c24017a71822fc02d/lib/appmenuapplet.cpp#L167
-            const QVariant data = m_appMenuModel->data(index, AppMenuModel::ActionRole);
-            QAction *itemAction = (QAction *)data.value<void *>();
-
-            // qCDebug(category) << "    " << itemAction;
-
-            TextButton *b = new TextButton(deco, row, this);
-            b->setText(itemLabel);
-            b->setAction(itemAction);
-            b->setOpacity(m_opacity);
-
-            // Skip items with empty labels (The first item in a Gtk app)
-            if (itemLabel.isEmpty()) {
-                b->setEnabled(false);
-                b->setVisible(false);
-            }
-            
-            addButton(QPointer<KDecoration2::DecorationButton>(b));
-        }
-        m_overflowIndex = m_appMenuModel->rowCount();
-        addButton(new MenuOverflowButton(deco, m_overflowIndex, this));
-
-        emit menuUpdated();
-
-    } else {
-        // Init AppMenuModel
-        // qCDebug(category) << "windowId" << decoratedClient->windowId();
-        if (KWindowSystem::isPlatformX11()) {
-#if HAVE_X11
-            WId windowId = decoratedClient->windowId();
-            if (windowId != 0) {
-                initAppMenuModel();
-                m_appMenuModel->setWinId(windowId);
-                // qCDebug(category) << "AppMenuModel" << m_appMenuModel;
-            }
-#endif
-        } else if (KWindowSystem::isPlatformWayland()) {
-#if HAVE_Wayland
-            // TODO
-#endif
-        }
-    }
-}
-
-void AppMenuButtonGroup::updateOverflow(QRectF availableRect)
-{
-    // qCDebug(category) << "updateOverflow" << availableRect;
-    bool showOverflow = false;
-    for (KDecoration2::DecorationButton *button : buttons()) {
-        // qCDebug(category) << "    " << button->geometry() << button;
-        if (qobject_cast<MenuOverflowButton *>(button)) {
-            button->setVisible(showOverflow);
-            // qCDebug(category) << "    showOverflow" << showOverflow;
-        } else if (qobject_cast<TextButton *>(button)) {
-            if (button->isEnabled()) {
-                if (availableRect.contains(button->geometry())) {
-                    button->setVisible(true);
-                } else {
-                    button->setVisible(false);
-                    showOverflow = true;
-                }
-            }
-        }
-    }
-    setOverflowing(showOverflow);
-}
-
-void AppMenuButtonGroup::trigger(int buttonIndex) {
-    // qCDebug(category) << "AppMenuButtonGroup::trigger" << buttonIndex;
-    KDecoration2::DecorationButton* button = buttons().value(buttonIndex);
-
-    // https://github.com/psifidotos/applet-window-appmenu/blob/908e60831d7d68ee56a56f9c24017a71822fc02d/lib/appmenuapplet.cpp#L167
-    QMenu *actionMenu = nullptr;
-
-    if (buttonIndex == m_appMenuModel->rowCount()) {
-        // Overflow Menu
-        actionMenu = new QMenu();
-        actionMenu->setAttribute(Qt::WA_DeleteOnClose);
-
-        int overflowStartsAt = 0;
-        for (KDecoration2::DecorationButton *b : buttons()) {
-            TextButton* textButton = qobject_cast<TextButton *>(b);
-            if (textButton && textButton->isEnabled() && !textButton->isVisible()) {
-                overflowStartsAt = textButton->buttonIndex();
-                break;
-            }
-        }
-
-        QAction *action = nullptr;
-        for (int i = overflowStartsAt; i < m_appMenuModel->rowCount(); i++) {
-            const QModelIndex index = m_appMenuModel->index(i, 0);
-            const QVariant data = m_appMenuModel->data(index, AppMenuModel::ActionRole);
-            action = (QAction *)data.value<void *>();
-            actionMenu->addAction(action);
-        }
-
-    } else {
-        const QModelIndex modelIndex = m_appMenuModel->index(buttonIndex, 0);
-        const QVariant data = m_appMenuModel->data(modelIndex, AppMenuModel::ActionRole);
-        QAction *itemAction = (QAction *)data.value<void *>();
-        // qCDebug(category) << "    action" << itemAction;
-
-        if (itemAction) {
-            actionMenu = itemAction->menu();
-            // qCDebug(category) << "    menu" << actionMenu;
-        }
-    }
-
-    const auto *deco = qobject_cast<Decoration *>(decoration());
-    // if (actionMenu && deco) {
-    //     auto *decoratedClient = deco->client().toStrongRef().data();
-    //     actionMenu->setPalette(decoratedClient->palette());
-    // }
-
-    if (actionMenu && deco) {
-        QRectF buttonRect = button->geometry();
-        QPoint position = buttonRect.topLeft().toPoint();
-        QPoint rootPosition(position);
-        rootPosition += deco->windowPos();
-        // qCDebug(category) << "    windowPos" << windowPos;
-
-        // auto connection( QX11Info::connection() );
-
-        // button release event
-        // xcb_button_release_event_t releaseEvent;
-        // memset(&releaseEvent, 0, sizeof(releaseEvent));
-
-        // releaseEvent.response_type = XCB_BUTTON_RELEASE;
-        // releaseEvent.event =  windowId;
-        // releaseEvent.child = XCB_WINDOW_NONE;
-        // releaseEvent.root = QX11Info::appRootWindow();
-        // releaseEvent.event_x = position.x();
-        // releaseEvent.event_y = position.y();
-        // releaseEvent.root_x = rootPosition.x();
-        // releaseEvent.root_y = rootPosition.y();
-        // releaseEvent.detail = XCB_BUTTON_INDEX_1;
-        // releaseEvent.state = XCB_BUTTON_MASK_1;
-        // releaseEvent.time = XCB_CURRENT_TIME;
-        // releaseEvent.same_screen = true;
-        // xcb_send_event( connection, false, windowId, XCB_EVENT_MASK_BUTTON_RELEASE, reinterpret_cast<const char*>(&releaseEvent));
-
-        // xcb_ungrab_pointer( connection, XCB_TIME_CURRENT_TIME );
-        //---
-
-        actionMenu->installEventFilter(this);
-
-        if (!KWindowSystem::isPlatformWayland()) {
-            actionMenu->popup(rootPosition);
-        }
-
-        QMenu *oldMenu = m_currentMenu;
-        m_currentMenu = actionMenu;
-
-        if (oldMenu && oldMenu != actionMenu) {
-            // Don't reset the currentIndex when another menu is already shown
-            disconnect(oldMenu, &QMenu::aboutToHide, this, &AppMenuButtonGroup::onMenuAboutToHide);
-            oldMenu->hide();
-        }
-        if (0 <= m_currentIndex && m_currentIndex < buttons().length()) {
-            buttons().value(m_currentIndex)->setChecked(false);
-        }
-
-        if (KWindowSystem::isPlatformWayland()) {
-            actionMenu->popup(rootPosition);
-        }
-
-        setCurrentIndex(buttonIndex);
-        button->setChecked(true);
-
-        // FIXME TODO connect only once
-        connect(actionMenu, &QMenu::aboutToHide, this, &AppMenuButtonGroup::onMenuAboutToHide, Qt::UniqueConnection);
-    }
-}
-
-void AppMenuButtonGroup::triggerOverflow()
-{
-    // qCDebug(category) << "AppMenuButtonGroup::triggerOverflow" << m_overflowIndex;
-    trigger(m_overflowIndex);
-}
-
-// FIXME TODO doesn't work on submenu
-bool AppMenuButtonGroup::eventFilter(QObject *watched, QEvent *event)
-{
-    auto *menu = qobject_cast<QMenu *>(watched);
-
-    if (!menu) {
-        return false;
-    }
-
-    if (event->type() == QEvent::KeyPress) {
-        auto *e = static_cast<QKeyEvent *>(event);
-
-        // TODO right to left languages
-        if (e->key() == Qt::Key_Left) {
-            int desiredIndex = m_currentIndex - 1;
-            emit requestActivateIndex(desiredIndex);
-            return true;
-        } else if (e->key() == Qt::Key_Right) {
-            if (menu->activeAction() && menu->activeAction()->menu()) {
-                return false;
-            }
-
-            int desiredIndex = m_currentIndex + 1;
-            emit requestActivateIndex(desiredIndex);
-            return true;
-        }
-
-    } else if (event->type() == QEvent::MouseMove) {
-        auto *e = static_cast<QMouseEvent *>(event);
-
-        const auto *deco = qobject_cast<Decoration *>(decoration());
-
-        QPoint decoPos(e->globalPos());
-        decoPos -= deco->windowPos();
-        decoPos.ry() += deco->titleBarHeight();
-        // qCDebug(category) << "MouseMove";
-        // qCDebug(category) << "       globalPos" << e->globalPos();
-        // qCDebug(category) << "       windowPos" << deco->windowPos();
-        // qCDebug(category) << "  titleBarHeight" << deco->titleBarHeight();
-
-        KDecoration2::DecorationButton* item = buttonAt(decoPos.x(), decoPos.y());
-        if (!item) {
-            return false;
-        }
-
-        AppMenuButton* appMenuButton = qobject_cast<AppMenuButton *>(item);
-        if (appMenuButton) {
-            if (m_currentIndex != appMenuButton->buttonIndex()
-                && appMenuButton->isVisible()
-                && appMenuButton->isEnabled()
-            ) {
-                emit requestActivateIndex(appMenuButton->buttonIndex());
-            }
-            return false;
-        }
-    }
-
-    return false;
-}
-
-bool AppMenuButtonGroup::isMenuOpen() const
-{
-    return 0 <= m_currentIndex;
-}
-
-void AppMenuButtonGroup::unPressAllButtons()
-{
-    // qCDebug(category) << "AppMenuButtonGroup::unPressAllButtons";
-    for (int i = 0; i < buttons().length(); i++) {
-        KDecoration2::DecorationButton* button = buttons().value(i);
-
-        // Hack to setPressed(false)
-        button->setEnabled(!button->isEnabled());
-        button->setEnabled(!button->isEnabled());
-    }
-}
-
-void AppMenuButtonGroup::updateShowing()
-{
-    setShowing(m_alwaysShow || m_hovered || isMenuOpen());
-}
-
-void AppMenuButtonGroup::onMenuAboutToHide()
-{
-    if (0 <= m_currentIndex && m_currentIndex < buttons().length()) {
-        buttons().value(m_currentIndex)->setChecked(false);
-    }
-    setCurrentIndex(-1);
-}
-
-void AppMenuButtonGroup::onShowingChanged(bool showing)
-{
-    if (m_animationEnabled) {
-        QAbstractAnimation::Direction dir = showing ? QAbstractAnimation::Forward : QAbstractAnimation::Backward;
-        if (m_animation->state() == QAbstractAnimation::Running && m_animation->direction() != dir) {
-            m_animation->stop();
-        }
-        m_animation->setDirection(dir);
-        if (m_animation->state() != QAbstractAnimation::Running) {
-            m_animation->start();
-        }
-    } else {
-        setOpacity(showing ? 1 : 0);
-    }
-}
-
-} // namespace Material
diff --git a/src/AppMenuButtonGroup.h b/src/AppMenuButtonGroup.h
deleted file mode 100644
index d86edb6..0000000
--- a/src/AppMenuButtonGroup.h
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * Copyright (C) 2020 Chris Holland <zrenfire@gmail.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program. If not, see <http://www.gnu.org/licenses/>.
- */
-
-#pragma once
-
-// own
-#include "AppMenuModel.h"
-
-// KDecoration
-#include <KDecoration2/DecoratedClient>
-#include <KDecoration2/DecorationButton>
-#include <KDecoration2/DecorationButtonGroup>
-
-// Qt
-#include <QMenu>
-#include <QVariantAnimation>
-
-namespace Material
-{
-
-class Decoration;
-
-class AppMenuButtonGroup : public KDecoration2::DecorationButtonGroup
-{
-    Q_OBJECT
-
-public:
-    AppMenuButtonGroup(Decoration *decoration);
-    ~AppMenuButtonGroup() override;
-
-    Q_PROPERTY(int currentIndex READ currentIndex WRITE setCurrentIndex NOTIFY currentIndexChanged)
-    Q_PROPERTY(int overflowing READ overflowing WRITE setOverflowing NOTIFY overflowingChanged)
-    Q_PROPERTY(bool hovered READ hovered WRITE setHovered NOTIFY hoveredChanged)
-    Q_PROPERTY(bool showing READ showing WRITE setShowing NOTIFY showingChanged)
-    Q_PROPERTY(bool alwaysShow READ alwaysShow WRITE setAlwaysShow NOTIFY alwaysShowChanged)
-    Q_PROPERTY(bool animationEnabled READ animationEnabled WRITE setAnimationEnabled NOTIFY animationEnabledChanged)
-    Q_PROPERTY(int animationDuration READ animationDuration WRITE setAnimationDuration NOTIFY animationDurationChanged)
-    Q_PROPERTY(qreal opacity READ opacity WRITE setOpacity NOTIFY opacityChanged)
-
-    int currentIndex() const;
-    void setCurrentIndex(int set);
-
-    bool overflowing() const;
-    void setOverflowing(bool set);
-
-    bool hovered() const;
-    void setHovered(bool value);
-
-    bool showing() const;
-    void setShowing(bool value);
-
-    bool alwaysShow() const;
-    void setAlwaysShow(bool value);
-
-    bool animationEnabled() const;
-    void setAnimationEnabled(bool value);
-
-    int animationDuration() const;
-    void setAnimationDuration(int duration);
-
-    qreal opacity() const;
-    void setOpacity(qreal value);
-
-    bool isMenuOpen() const;
-
-    KDecoration2::DecorationButton* buttonAt(int x, int y) const;
-
-    void unPressAllButtons();
-
-public slots:
-    void initAppMenuModel();
-    void updateAppMenuModel();
-    void updateOverflow(QRectF availableRect);
-    void trigger(int index);
-    void triggerOverflow();
-    void updateShowing();
-    void onMenuAboutToHide();
-
-private slots:
-    void onShowingChanged(bool hovered);
-
-signals:
-    void menuUpdated();
-    void requestActivateIndex(int index);
-    void requestActivateOverflow();
-
-    void currentIndexChanged();
-    void overflowingChanged();
-    void hoveredChanged(bool);
-    void showingChanged(bool);
-    void alwaysShowChanged(bool);
-    void animationEnabledChanged(bool);
-    void animationDurationChanged(int);
-    void opacityChanged(qreal);
-
-protected:
-    bool eventFilter(QObject *watched, QEvent *event) override;
-
-private:
-    void resetButtons();
-
-    AppMenuModel *m_appMenuModel;
-    int m_currentIndex;
-    int m_overflowIndex;
-    bool m_overflowing;
-    bool m_hovered;
-    bool m_showing;
-    bool m_alwaysShow;
-    bool m_animationEnabled;
-    QVariantAnimation *m_animation;
-    qreal m_opacity;
-    QPointer<QMenu> m_currentMenu;
-};
-
-} // namespace Material
diff --git a/src/AppMenuModel.cc b/src/AppMenuModel.cc
deleted file mode 100644
index fa1405f..0000000
--- a/src/AppMenuModel.cc
+++ /dev/null
@@ -1,459 +0,0 @@
-/******************************************************************
- * Copyright 2016 Kai Uwe Broulik <kde@privat.broulik.de>
- * Copyright 2016 Chinmoy Ranjan Pradhan <chinmoyrp65@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License or (at your option) version 3 or any later version
- * accepted by the membership of KDE e.V. (or its successor approved
- * by the membership of KDE e.V.), which shall act as a proxy
- * defined in Section 14 of version 3 of the license.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- ******************************************************************/
-
-// Based on:
-// https://invent.kde.org/plasma/plasma-workspace/-/blob/master/applets/appmenu/plugin/appmenumodel.cpp
-// https://github.com/psifidotos/applet-window-appmenu/blob/master/plugin/appmenumodel.cpp
-
-// own
-#include "AppMenuModel.h"
-#include "Material.h"
-#include "BuildConfig.h"
-
-// KF
-#include <KWindowSystem>
-// In KF5 5.101, KWindowSystem moved several signals to KX11Extras
-// Eg: https://invent.kde.org/frameworks/kwindowsystem/-/commit/7cfd7c36eb017242d7a0202db82895be6b8fb81c
-#if HAVE_KF5_101 // KX11Extras
-#include <KX11Extras>
-#endif
-
-// Qt
-#include <QAction>
-#include <QDebug>
-#include <QMenu>
-#include <QDBusConnection>
-#include <QDBusConnectionInterface>
-#include <QDBusServiceWatcher>
-#include <QGuiApplication>
-
-// libdbusmenuqt
-#include <dbusmenuimporter.h>
-
-#if HAVE_X11
-#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
-#include <private/qtx11extras_p.h>
-#else
-#include <QX11Info>
-#endif
-#include <xcb/xcb.h>
-#endif
-
-
-namespace Material
-{
-
-static const QByteArray s_x11AppMenuServiceNamePropertyName = QByteArrayLiteral("_KDE_NET_WM_APPMENU_SERVICE_NAME");
-static const QByteArray s_x11AppMenuObjectPathPropertyName = QByteArrayLiteral("_KDE_NET_WM_APPMENU_OBJECT_PATH");
-
-#if HAVE_X11
-static QHash<QByteArray, xcb_atom_t> s_atoms;
-#endif
-
-class KDBusMenuImporter : public DBusMenuImporter
-{
-
-public:
-    KDBusMenuImporter(const QString &service, const QString &path, QObject *parent)
-        : DBusMenuImporter(service, path, parent) {
-
-    }
-
-protected:
-    QIcon iconForName(const QString &name) override {
-        return QIcon::fromTheme(name);
-    }
-
-};
-
-AppMenuModel::AppMenuModel(QObject *parent)
-    : QAbstractListModel(parent),
-      m_serviceWatcher(new QDBusServiceWatcher(this))
-{
-    if (KWindowSystem::isPlatformX11()) {
-#if HAVE_X11
-        x11Init();
-#else
-        // Not compiled with X11
-        return;
-#endif
-
-    } else if (KWindowSystem::isPlatformWayland()) {
-#if HAVE_Wayland
-        // TODO
-        // waylandInit();
-        return;
-#else
-        // Not compiled with KWayland
-        return;
-#endif
-
-    } else {
-        // Not X11 or Wayland
-        return;
-    }
-
-    m_serviceWatcher->setConnection(QDBusConnection::sessionBus());
-    // If our current DBus connection gets lost, close the menu
-    // we'll select the new menu when the focus changes
-    connect(m_serviceWatcher, &QDBusServiceWatcher::serviceUnregistered, this, [this](const QString & serviceName) {
-        if (serviceName == m_serviceName) {
-            setMenuAvailable(false);
-            emit modelNeedsUpdate();
-        }
-    });
-}
-
-AppMenuModel::~AppMenuModel() = default;
-
-void AppMenuModel::x11Init()
-{
-#if HAVE_X11
-    connect(this, &AppMenuModel::winIdChanged,
-            this, &AppMenuModel::onWinIdChanged);
-
-// In KF5 5.101, KWindowSystem moved several signals to KX11Extras
-// Eg: https://invent.kde.org/frameworks/kwindowsystem/-/commit/7cfd7c36eb017242d7a0202db82895be6b8fb81c
-#if HAVE_KF5_101 // KX11Extras
-    // Select non-deprecated overloaded method. Uses coding pattern from:
-    // https://invent.kde.org/plasma/plasma-workspace/blame/master/libtaskmanager/xwindowsystemeventbatcher.cpp#L30
-    void (KX11Extras::*myWindowChangeSignal)(WId window, NET::Properties properties, NET::Properties2 properties2) = &KX11Extras::windowChanged;
-    connect(KX11Extras::self(), myWindowChangeSignal,
-            this, &AppMenuModel::onX11WindowChanged);
-
-    // There are apps that are not releasing their menu properly after closing
-    // and as such their menu is still shown even though the app does not exist
-    // any more. Such apps are Java based e.g. smartgit
-    connect(KX11Extras::self(), &KX11Extras::windowRemoved,
-            this, &AppMenuModel::onX11WindowRemoved);
-#else // KF5 5.100 KWindowSystem
-    void (KWindowSystem::*myWindowChangeSignal)(WId window, NET::Properties properties, NET::Properties2 properties2) = &KWindowSystem::windowChanged;
-    connect(KWindowSystem::self(), myWindowChangeSignal,
-            this, &AppMenuModel::onX11WindowChanged);
-    connect(KWindowSystem::self(), &KWindowSystem::windowRemoved,
-            this, &AppMenuModel::onX11WindowRemoved);
-#endif
-
-    connect(this, &AppMenuModel::modelNeedsUpdate, this, [this] {
-        if (!m_updatePending) {
-            m_updatePending = true;
-            QMetaObject::invokeMethod(this, "update", Qt::QueuedConnection);
-        }
-    });
-#endif
-}
-
-void AppMenuModel::waylandInit()
-{
-#if HAVE_Wayland
-    // TODO
-#endif
-}
-
-bool AppMenuModel::menuAvailable() const
-{
-    return m_menuAvailable;
-}
-
-void AppMenuModel::setMenuAvailable(bool set)
-{
-    if (m_menuAvailable != set) {
-        m_menuAvailable = set;
-        emit menuAvailableChanged();
-    }
-}
-
-QVariant AppMenuModel::winId() const
-{
-    return m_winId;
-}
-
-void AppMenuModel::setWinId(const QVariant &id)
-{
-    if (m_winId == id) {
-        return;
-    }
-    qCDebug(category) << "AppMenuModel::setWinId" << m_winId << " => " << id;
-    m_winId = id;
-    emit winIdChanged();
-}
-
-int AppMenuModel::rowCount(const QModelIndex &parent) const
-{
-    Q_UNUSED(parent);
-
-    if (!m_menuAvailable || !m_menu) {
-        return 0;
-    }
-
-    return m_menu->actions().count();
-}
-
-void AppMenuModel::update()
-{
-    // qCDebug(category) << "AppMenuModel::update (" << m_winId << ")";
-    beginResetModel();
-    endResetModel();
-    m_updatePending = false;
-}
-
-
-void AppMenuModel::onWinIdChanged()
-{
-
-    if (KWindowSystem::isPlatformX11()) {
-#if HAVE_X11
-
-        qApp->removeNativeEventFilter(this);
-
-        const WId id = m_winId.toUInt();
-
-        if (!id) {
-            setMenuAvailable(false);
-            emit modelNeedsUpdate();
-            return;
-        }
-
-        auto *c = QX11Info::connection();
-
-        auto getWindowPropertyString = [c](WId id, const QByteArray &name) -> QByteArray {
-            QByteArray value;
-
-            if (!s_atoms.contains(name))
-            {
-                const xcb_intern_atom_cookie_t atomCookie = xcb_intern_atom(c, false, name.length(), name.constData());
-                QScopedPointer<xcb_intern_atom_reply_t, QScopedPointerPodDeleter> atomReply(xcb_intern_atom_reply(c, atomCookie, nullptr));
-
-                if (atomReply.isNull()) {
-                    return value;
-                }
-
-                s_atoms[name] = atomReply->atom;
-
-                if (s_atoms[name] == XCB_ATOM_NONE) {
-                    return value;
-                }
-            }
-
-            static const long MAX_PROP_SIZE = 10000;
-            auto propertyCookie = xcb_get_property(c, false, id, s_atoms[name], XCB_ATOM_STRING, 0, MAX_PROP_SIZE);
-            QScopedPointer<xcb_get_property_reply_t, QScopedPointerPodDeleter> propertyReply(xcb_get_property_reply(c, propertyCookie, nullptr));
-
-            if (propertyReply.isNull())
-            {
-                return value;
-            }
-
-            if (propertyReply->type == XCB_ATOM_STRING && propertyReply->format == 8 && propertyReply->value_len > 0)
-            {
-                const char *data = (const char *) xcb_get_property_value(propertyReply.data());
-                int len = propertyReply->value_len;
-
-                if (data) {
-                    value = QByteArray(data, data[len - 1] ? len : len - 1);
-                }
-            }
-
-            return value;
-        };
-
-        auto updateMenuFromWindowIfHasMenu = [this, &getWindowPropertyString](WId id) {
-            const QString serviceName = QString::fromUtf8(getWindowPropertyString(id, s_x11AppMenuServiceNamePropertyName));
-            const QString menuObjectPath = QString::fromUtf8(getWindowPropertyString(id, s_x11AppMenuObjectPathPropertyName));
-
-            if (!serviceName.isEmpty() && !menuObjectPath.isEmpty()) {
-                updateApplicationMenu(serviceName, menuObjectPath);
-                return true;
-            }
-
-            return false;
-        };
-
-        if (updateMenuFromWindowIfHasMenu(id)) {
-            return;
-        }
-
-        // monitor whether an app menu becomes available later
-        // this can happen when an app starts, shows its window, and only later announces global menu (e.g. Firefox)
-        qApp->installNativeEventFilter(this);
-        m_delayedMenuWindowId = id;
-
-        //no menu found, set it to unavailable
-        setMenuAvailable(false);
-        emit modelNeedsUpdate();
-#endif
-
-    } else if (KWindowSystem::isPlatformWayland()) {
-#if HAVE_Wayland
-        // TODO
-#endif
-    }
-}
-
-void AppMenuModel::onX11WindowChanged(WId id)
-{
-    if (m_winId.toUInt() == id) {
-        
-    }
-}
-
-void AppMenuModel::onX11WindowRemoved(WId id)
-{
-    if (m_winId.toUInt() == id) {
-        setMenuAvailable(false);
-    }
-}
-
-QHash<int, QByteArray> AppMenuModel::roleNames() const
-{
-    QHash<int, QByteArray> roleNames;
-    roleNames[MenuRole] = QByteArrayLiteral("activeMenu");
-    roleNames[ActionRole] = QByteArrayLiteral("activeActions");
-    return roleNames;
-}
-
-QVariant AppMenuModel::data(const QModelIndex &index, int role) const
-{
-    const int row = index.row();
-
-    if (row < 0 || !m_menuAvailable || !m_menu) {
-        return QVariant();
-    }
-
-    const auto actions = m_menu->actions();
-
-    if (row >= actions.count()) {
-        return QVariant();
-    }
-
-    if (role == MenuRole) { // TODO this should be Qt::DisplayRole
-        return actions.at(row)->text();
-    } else if (role == ActionRole) {
-        return QVariant::fromValue((void *) actions.at(row));
-    }
-
-    return QVariant();
-}
-
-void AppMenuModel::updateApplicationMenu(const QString &serviceName, const QString &menuObjectPath)
-{
-    if (m_serviceName == serviceName && m_menuObjectPath == menuObjectPath) {
-        if (m_importer) {
-            QMetaObject::invokeMethod(m_importer, "updateMenu", Qt::QueuedConnection);
-        }
-        return;
-    }
-
-    m_serviceName = serviceName;
-    m_serviceWatcher->setWatchedServices(QStringList({m_serviceName}));
-
-    m_menuObjectPath = menuObjectPath;
-
-    if (m_importer) {
-        m_importer->deleteLater();
-    }
-
-    m_importer = new KDBusMenuImporter(serviceName, menuObjectPath, this);
-    QMetaObject::invokeMethod(m_importer, "updateMenu", Qt::QueuedConnection);
-
-    connect(m_importer.data(), &DBusMenuImporter::menuUpdated, this, [=](QMenu *menu) {
-        m_menu = m_importer->menu();
-        if (m_menu.isNull() || menu != m_menu) {
-            return;
-        }
-
-        // cache first layer of sub menus, which we'll be popping up
-        const auto actions = m_menu->actions();
-        for (QAction *a : actions) {
-            // signal dataChanged when the action changes
-            connect(a, &QAction::changed, this, [this, a] {
-                if (m_menuAvailable && m_menu) {
-                    const int actionIdx = m_menu->actions().indexOf(a);
-                    if (actionIdx > -1) {
-                        const QModelIndex modelIdx = index(actionIdx, 0);
-                        emit dataChanged(modelIdx, modelIdx);
-                    }
-                }
-            });
-
-            connect(a, &QAction::destroyed, this, &AppMenuModel::modelNeedsUpdate);
-
-            if (a->menu()) {
-                m_importer->updateMenu(a->menu());
-            }
-        }
-
-        setMenuAvailable(true);
-        emit modelNeedsUpdate();
-    });
-
-    connect(m_importer.data(), &DBusMenuImporter::actionActivationRequested, this, [this](QAction *action) {
-        // TODO submenus
-        if (!m_menuAvailable || !m_menu) {
-            return;
-        }
-
-        const auto actions = m_menu->actions();
-        auto it = std::find(actions.begin(), actions.end(), action);
-        if (it != actions.end()) {
-            emit requestActivateIndex(it - actions.begin());
-        }
-    });
-}
-
-bool AppMenuModel::nativeEventFilter(const QByteArray &eventType, void *message, long *result)
-{
-    Q_UNUSED(result);
-
-    if (!KWindowSystem::isPlatformX11() || eventType != "xcb_generic_event_t") {
-        return false;
-    }
-
-#if HAVE_X11
-    auto e = static_cast<xcb_generic_event_t *>(message);
-    const uint8_t type = e->response_type & ~0x80;
-
-    if (type == XCB_PROPERTY_NOTIFY) {
-        auto *event = reinterpret_cast<xcb_property_notify_event_t *>(e);
-
-        if (event->window == m_delayedMenuWindowId) {
-
-            auto serviceNameAtom = s_atoms.value(s_x11AppMenuServiceNamePropertyName);
-            auto objectPathAtom = s_atoms.value(s_x11AppMenuObjectPathPropertyName);
-
-            if (serviceNameAtom != XCB_ATOM_NONE && objectPathAtom != XCB_ATOM_NONE) { // shouldn't happen
-                if (event->atom == serviceNameAtom || event->atom == objectPathAtom) {
-                    // see if we now have a menu
-                    onWinIdChanged();
-                }
-            }
-        }
-    }
-
-#else
-    Q_UNUSED(message);
-#endif
-
-    return false;
-}
-
-} // namespace Material
diff --git a/src/AppMenuModel.h b/src/AppMenuModel.h
deleted file mode 100644
index b242068..0000000
--- a/src/AppMenuModel.h
+++ /dev/null
@@ -1,111 +0,0 @@
-/******************************************************************
- * Copyright 2016 Chinmoy Ranjan Pradhan <chinmoyrp65@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License or (at your option) version 3 or any later version
- * accepted by the membership of KDE e.V. (or its successor approved
- * by the membership of KDE e.V.), which shall act as a proxy
- * defined in Section 14 of version 3 of the license.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- ******************************************************************/
-
-#pragma once
-
-// Qt
-#include <QAbstractListModel>
-#include <QAbstractNativeEventFilter>
-#include <QAction>
-#include <QDBusServiceWatcher>
-#include <QMenu>
-#include <QModelIndex>
-#include <QPointer>
-#include <QRect>
-#include <QStringList>
-
-
-namespace Material
-{
-
-class KDBusMenuImporter;
-
-class AppMenuModel : public QAbstractListModel, public QAbstractNativeEventFilter
-{
-    Q_OBJECT
-
-    Q_PROPERTY(bool menuAvailable READ menuAvailable WRITE setMenuAvailable NOTIFY menuAvailableChanged)
-    Q_PROPERTY(QVariant winId READ winId WRITE setWinId NOTIFY winIdChanged)
-
-public:
-    explicit AppMenuModel(QObject *parent = nullptr);
-    ~AppMenuModel() override;
-
-private:
-    void x11Init();
-    void waylandInit();
-
-public:
-    enum AppMenuRole
-    {
-        MenuRole = Qt::UserRole + 1, // TODO this should be Qt::DisplayRole
-        ActionRole
-    };
-
-    QVariant data(const QModelIndex &index, int role) const override;
-    int rowCount(const QModelIndex &parent = QModelIndex()) const override;
-    QHash<int, QByteArray> roleNames() const override;
-
-    void updateApplicationMenu(const QString &serviceName, const QString &menuObjectPath);
-
-    bool menuAvailable() const;
-    void setMenuAvailable(bool set);
-
-    QVariant winId() const;
-    void setWinId(const QVariant &id);
-
-signals:
-    void requestActivateIndex(int index);
-
-protected:
-    bool nativeEventFilter(const QByteArray &eventType, void *message, long int *result) override;
-
-private Q_SLOTS:
-    void onWinIdChanged();
-    void onX11WindowChanged(WId id);
-    void onX11WindowRemoved(WId id);
-
-    void update();
-
-signals:
-    void menuAvailableChanged();
-    void modelNeedsUpdate();
-    void winIdChanged();
-
-private:
-    bool m_menuAvailable;
-    bool m_updatePending = false;
-
-    QVariant m_winId{-1};
-
-    //! window that its menu initialization may be delayed
-    WId m_delayedMenuWindowId = 0;
-
-    QPointer<QMenu> m_menu;
-
-    QDBusServiceWatcher *m_serviceWatcher;
-    QString m_serviceName;
-    QString m_menuObjectPath;
-
-    QPointer<KDBusMenuImporter> m_importer;
-};
-
-} // namespace Material
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 78a5289..19d61af 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -78,14 +78,9 @@ message(STATUS "HAVE_KF5_101: ${HAVE_KF5_101} (${KF5_VERSION})")
 configure_file(BuildConfig.h.cmake ${CMAKE_CURRENT_BINARY_DIR}/BuildConfig.h)
 
 set (decoration_SRCS
-    AppMenuModel.cc
-    AppMenuButton.cc
-    AppMenuButtonGroup.cc
     BoxShadowHelper.cc
     Button.cc
     Decoration.cc
-    MenuOverflowButton.cc
-    TextButton.cc
     ConfigurationModule.cc
     plugin.cc
 )
@@ -100,7 +95,6 @@ add_library (materialdecoration MODULE
 
 target_link_libraries (materialdecoration
     PUBLIC
-        dbusmenuqt
         Qt${QT_VERSION_MAJOR}::Core
         Qt${QT_VERSION_MAJOR}::Gui
         # Qt${QT_VERSION_MAJOR}::X11Extras
diff --git a/src/ConfigurationModule.cc b/src/ConfigurationModule.cc
index 55a9462..1f78ebb 100644
--- a/src/ConfigurationModule.cc
+++ b/src/ConfigurationModule.cc
@@ -114,43 +114,6 @@ void ConfigurationModule::init()
     inactiveOpacity->setObjectName(QStringLiteral("kcfg_InactiveOpacity"));
     generalForm->addRow(i18n("Inactive Opacity:"), inactiveOpacity);
 
-
-    //--- Menu
-    QWidget *menuTab = new QWidget(tabWidget);
-    tabWidget->addTab(menuTab, i18n("Menu"));
-    QFormLayout *menuForm = new QFormLayout(menuTab);
-    menuTab->setLayout(menuForm);
-
-    QLabel *menuLabel = new QLabel(menuTab);
-    menuLabel->setText(i18n("To enable the Locally Integrated Menus in the titlebar:\nSystem Settings > Window Decorations > Titlebar Buttons Tab\nDrag the 'Application Menu' button to bar."));
-    menuForm->addRow(QStringLiteral(""), menuLabel);
-
-    QRadioButton *menuAlwaysShow = new QRadioButton(menuTab);
-    menuAlwaysShow->setText(i18n("Always Show Menu"));
-    menuAlwaysShow->setObjectName(QStringLiteral("kcfg_MenuAlwaysShow"));
-    menuForm->addRow(QStringLiteral(""), menuAlwaysShow);
-
-    // Since there's no easy way to bind this to !MenuAlwaysShow, we
-    // workaround this by marking the button as checked on init.
-    // When the config is loaded:
-    // * If menuAlwaysShow is toggled true, this will be toggled false.
-    // * If menuAlwaysShow is left false, then this remains true.
-    QRadioButton *menuRevealOnHover = new QRadioButton(menuTab);
-    menuRevealOnHover->setText(i18n("Reveal Menu on Hover"));
-    menuRevealOnHover->setChecked(true);
-    menuForm->addRow(QStringLiteral(""), menuRevealOnHover);
-
-    QButtonGroup *menuAlwaysShowGroup = new QButtonGroup(menuTab);
-    menuAlwaysShowGroup->addButton(menuAlwaysShow);
-    menuAlwaysShowGroup->addButton(menuRevealOnHover);
-
-    QSpinBox *menuButtonHorzPadding = new QSpinBox(menuTab);
-    menuButtonHorzPadding->setMinimum(0);
-    menuButtonHorzPadding->setMaximum(INT_MAX);
-    menuButtonHorzPadding->setObjectName(QStringLiteral("kcfg_MenuButtonHorzPadding"));
-    menuForm->addRow(i18n("Padding:"), menuButtonHorzPadding);
-
-
     //--- Animations
     QWidget *animationsTab = new QWidget(tabWidget);
     tabWidget->addTab(animationsTab, i18nd("breeze_kwin_deco", "Animations"));
@@ -221,18 +184,6 @@ void ConfigurationModule::init()
         0.85,
         QStringLiteral("InactiveOpacity")
     );
-    skel->addItemBool(
-        QStringLiteral("MenuAlwaysShow"),
-        m_menuAlwaysShow,
-        true,
-        QStringLiteral("MenuAlwaysShow")
-    );
-    skel->addItemInt(
-        QStringLiteral("MenuButtonHorzPadding"),
-        m_menuButtonHorzPadding,
-        1,
-        QStringLiteral("MenuButtonHorzPadding")
-    );
     skel->addItemBool(
         QStringLiteral("AnimationsEnabled"),
         m_animationsEnabled,
diff --git a/src/Decoration.cc b/src/Decoration.cc
index aff2016..1cca7dd 100644
--- a/src/Decoration.cc
+++ b/src/Decoration.cc
@@ -22,7 +22,6 @@
 #include "Decoration.h"
 #include "Material.h"
 #include "BuildConfig.h"
-#include "AppMenuButtonGroup.h"
 #include "BoxShadowHelper.h"
 #include "Button.h"
 #include "InternalSettings.h"
@@ -229,16 +228,6 @@ void Decoration::init()
         this,
         &Button::create);
 
-    m_menuButtons = new AppMenuButtonGroup(this);
-    connect(m_menuButtons, &AppMenuButtonGroup::menuUpdated,
-            this, &Decoration::updateButtonsGeometry);
-    connect(m_menuButtons, &AppMenuButtonGroup::opacityChanged,
-            this, repaintTitleBar);
-    connect(m_menuButtons, &AppMenuButtonGroup::alwaysShowChanged,
-            this, repaintTitleBar);
-    m_menuButtons->updateAppMenuModel();
-
-
     connect(decoratedClient, &KDecoration2::DecoratedClient::widthChanged,
             this, &Decoration::updateTitleBar);
     connect(decoratedClient, &KDecoration2::DecoratedClient::widthChanged,
@@ -295,7 +284,6 @@ void Decoration::reconfigure()
 
     updateBorders();
     updateTitleBar();
-    m_menuButtons->setAlwaysShow(m_internalSettings->menuAlwaysShow());
     updateButtonsGeometry();
     updateButtonAnimation();
     updateShadow();
@@ -306,20 +294,6 @@ void Decoration::mousePressEvent(QMouseEvent *event)
 {
     KDecoration2::Decoration::mousePressEvent(event);
     // qCDebug(category) << "Decoration::mousePressEvent" << event;
-
-    if (m_menuButtons->geometry().contains(event->pos())) {
-        if (event->button() == Qt::LeftButton) {
-            initDragMove(event->pos());
-            event->setAccepted(false);
-
-        // If AppMenuButton's do not handle the button
-        } else if (event->button() == Qt::MiddleButton || event->button() == Qt::RightButton) {
-            // Don't accept the event. KDecoration2 will
-            // accept the event even if it doesn't pass
-            // button->acceptableButtons()->testFlag(button)
-            event->setAccepted(false);
-        }
-    }
 }
 
 void Decoration::hoverEnterEvent(QHoverEvent *event)
@@ -335,23 +309,6 @@ void Decoration::hoverMoveEvent(QHoverEvent *event)
     KDecoration2::Decoration::hoverMoveEvent(event);
     // qCDebug(category) << "Decoration::hoverMoveEvent" << event;
 
-    const bool dragStarted = dragMoveTick(event->pos());
-    // qCDebug(category) << "    " << "dragStarted" << dragStarted;
-    if (dragStarted) {
-        m_menuButtons->unPressAllButtons();
-    }
-
-    // const bool wasHovered = m_menuButtons->hovered();
-    // const bool contains = m_menuButtons->geometry().contains(event->posF());
-    // if (!wasHovered && contains) {
-    //     // HoverEnter
-    //     m_menuButtons->setHovered(true);
-    // } else if (wasHovered && !contains) {
-    //     // HoverLeave
-    //     m_menuButtons->setHovered(false);
-    // } else if (wasHovered && contains) {
-    //     // HoverMove
-    // }
     updateBlur();
 }
 
@@ -376,17 +333,7 @@ void Decoration::hoverLeaveEvent(QHoverEvent *event)
 
 void Decoration::wheelEvent(QWheelEvent *event)
 {
-    #if QT_VERSION >= QT_VERSION_CHECK(5, 14, 0)
-    const QPointF pos = event->position();
-    #else
-    const QPointF pos = event->posF();
-    #endif
-
-    if (m_menuButtons->geometry().contains(pos)) {
-        // Skip
-    } else {
-        KDecoration2::Decoration::wheelEvent(event);
-    }
+    KDecoration2::Decoration::wheelEvent(event);
 }
 
 void Decoration::onSectionUnderMouseChanged(const Qt::WindowFrameSection value)
@@ -434,17 +381,6 @@ void Decoration::updateTitleBar()
 
 void Decoration::updateTitleBarHoverState()
 {
-    const bool wasHovered = m_menuButtons->hovered();
-    const bool isHovered = titleBarIsHovered();
-    if (!wasHovered && isHovered) {
-        // HoverEnter
-        m_menuButtons->setHovered(true);
-    } else if (wasHovered && !isHovered) {
-        // HoverLeave
-        m_menuButtons->setHovered(false);
-    } else if (wasHovered && isHovered) {
-        // HoverMove
-    }
 }
 
 void Decoration::setButtonGroupHeight(KDecoration2::DecorationButtonGroup *buttonGroup, int buttonHeight)
@@ -487,7 +423,6 @@ void Decoration::updateButtonHeight()
     const int buttonHeight = titleBarHeight();
     setButtonGroupHeight(m_leftButtons, buttonHeight);
     setButtonGroupHeight(m_rightButtons, buttonHeight);
-    setButtonGroupHeight(m_menuButtons, buttonHeight);
 }
 
 void Decoration::updateButtonsGeometry()
@@ -517,21 +452,6 @@ void Decoration::updateButtonsGeometry()
     //     lastButton->padding()->setRight(rightOffset);
     // }
 
-    // Menu
-    if (!m_menuButtons->buttons().isEmpty()) {
-        const int captionOffset = captionMinWidth() + settings()->smallSpacing();
-        const QRect availableRect = centerRect().adjusted(
-            0,
-            0,
-            -captionOffset,
-            0
-        );
-        setButtonGroupHorzPadding(m_menuButtons, m_internalSettings->menuButtonHorzPadding());
-        m_menuButtons->setPos(availableRect.topLeft());
-        m_menuButtons->setSpacing(0);
-        m_menuButtons->updateOverflow(availableRect);
-    }
-
     update();
 }
 
@@ -550,11 +470,6 @@ void Decoration::updateButtonAnimation()
     const int duration = animationsDuration();
     setButtonGroupAnimation(m_leftButtons, enabled, duration);
     setButtonGroupAnimation(m_rightButtons, enabled, duration);
-    setButtonGroupAnimation(m_menuButtons, enabled, duration);
-
-    // Hover Animation
-    m_menuButtons->setAnimationEnabled(enabled);
-    m_menuButtons->setAnimationDuration(duration);
 }
 
 void Decoration::updateShadow()
@@ -1008,12 +923,8 @@ void Decoration::paintCaption(QPainter *painter, const QRect &repaintRegion) con
     const int textWidth = settings()->fontMetrics().boundingRect(decoratedClient->caption()).width();
     const QRect textRect((size().width() - textWidth) / 2, 0, textWidth, titleBarHeight());
 
-    const bool appMenuVisible = !m_menuButtons->buttons().isEmpty();
-    const int menuButtonsWidth = m_menuButtons->geometry().width()
-        + (appMenuVisible ? appMenuCaptionSpacing() : 0);
-
     const QRect availableRect = centerRect().adjusted(
-        (m_menuButtons->alwaysShow() ? menuButtonsWidth : 0),
+        0,
         0,
         0,
         0
@@ -1059,38 +970,7 @@ void Decoration::paintCaption(QPainter *painter, const QRect &repaintRegion) con
     painter->save();
     painter->setFont(settings()->font());
 
-    if (m_menuButtons->buttons().isEmpty()) {
-        painter->setPen(titleBarForegroundColor());
-    } else { // menuButtons is visible
-        const int menuRight = m_menuButtons->geometry().right();
-        const int textLeft = textRect.left();
-        const int textRight = textRect.right();
-        // qCDebug(category) << "textLeft" << textLeft << "menuRight" << menuRight;
-
-        if (!m_menuButtons->alwaysShow()) { // caption fades away revealing menu
-            painter->setOpacity(1.0 - m_menuButtons->opacity());
-            painter->setPen(titleBarForegroundColor());
-        } else if (m_menuButtons->overflowing()) { // hide caption leaving "whitespace" to easily grab.
-            painter->setPen(Qt::transparent);
-        } else if (textRight < menuRight) { // menuButtons completely coveres caption
-            painter->setPen(Qt::transparent);
-        } else if (textLeft < menuRight) { // menuButtons covers caption
-            const int fadeWidth = 10; // TODO: scale by dpi
-            const int x1 = menuRight;
-            const int x2 = qMin(x1+fadeWidth, textRight);
-            const float x1Ratio = (float)(x1-textLeft) / (float)textWidth;
-            const float x2Ratio = (float)(x2-textLeft) / (float)textWidth;
-            // qCDebug(category) << "    " << "x2" << x2 << "x1R" << x1Ratio << "x2R" << x2Ratio;
-            QLinearGradient gradient(textRect.topLeft(), textRect.bottomRight());
-            gradient.setColorAt(x1Ratio, Qt::transparent);
-            gradient.setColorAt(x2Ratio, titleBarForegroundColor());
-            QBrush brush(gradient);
-            QPen pen(brush, 1);
-            painter->setPen(pen);
-        } else { // caption is not covered by menuButtons
-            painter->setPen(titleBarForegroundColor());
-        }
-    }
+    painter->setPen(titleBarForegroundColor());
 
     painter->drawText(captionRect, alignment, caption);
     painter->restore();
@@ -1100,7 +980,6 @@ void Decoration::paintButtons(QPainter *painter, const QRect &repaintRegion) con
 {
     m_leftButtons->paint(painter, repaintRegion);
     m_rightButtons->paint(painter, repaintRegion);
-    m_menuButtons->paint(painter, repaintRegion);
 }
 
 void Decoration::paintOutline(QPainter *painter, const QRect &repaintRegion) const
diff --git a/src/Decoration.h b/src/Decoration.h
index 0033a01..7b7ab37 100644
--- a/src/Decoration.h
+++ b/src/Decoration.h
@@ -20,7 +20,6 @@
 
 // own
 #include "BuildConfig.h"
-#include "AppMenuButtonGroup.h"
 #include "InternalSettings.h"
 
 // KDecoration
@@ -129,7 +128,6 @@ private:
 
     KDecoration2::DecorationButtonGroup *m_leftButtons;
     KDecoration2::DecorationButtonGroup *m_rightButtons;
-    AppMenuButtonGroup *m_menuButtons;
 
     QSharedPointer<InternalSettings> m_internalSettings;
 
diff --git a/src/MenuOverflowButton.cc b/src/MenuOverflowButton.cc
deleted file mode 100644
index ab55f9e..0000000
--- a/src/MenuOverflowButton.cc
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright (C) 2020 Chris Holland <zrenfire@gmail.com>
- * Copyright (C) 2019 Zain Ahmad <zain.x.ahmad@gmail.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program. If not, see <http://www.gnu.org/licenses/>.
- */
-
-// own
-#include "MenuOverflowButton.h"
-#include "Material.h"
-#include "AppMenuButton.h"
-#include "Decoration.h"
-#include "ApplicationMenuButton.h"
-
-// KDecoration
-#include <KDecoration2/DecoratedClient>
-
-// Qt
-#include <QDebug>
-#include <QPainter>
-
-
-namespace Material
-{
-
-MenuOverflowButton::MenuOverflowButton(Decoration *decoration, const int buttonIndex, QObject *parent)
-    : AppMenuButton(decoration, buttonIndex, parent)
-{
-    auto *decoratedClient = decoration->client().toStrongRef().data();
-
-    setVisible(decoratedClient->hasApplicationMenu());
-}
-
-MenuOverflowButton::~MenuOverflowButton()
-{
-}
-
-void MenuOverflowButton::paintIcon(QPainter *painter, const QRectF &iconRect, const qreal gridUnit)
-{
-    ApplicationMenuButton::paintIcon(this, painter, iconRect, gridUnit);
-}
-
-} // namespace Material
diff --git a/src/MenuOverflowButton.h b/src/MenuOverflowButton.h
deleted file mode 100644
index 36c9b64..0000000
--- a/src/MenuOverflowButton.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright (C) 2020 Chris Holland <zrenfire@gmail.com>
- * Copyright (C) 2019 Zain Ahmad <zain.x.ahmad@gmail.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program. If not, see <http://www.gnu.org/licenses/>.
- */
-
-#pragma once
-
-// own
-#include "AppMenuButton.h"
-
-namespace Material
-{
-
-class Decoration;
-
-class MenuOverflowButton : public AppMenuButton
-{
-    Q_OBJECT
-
-public:
-    MenuOverflowButton(Decoration *decoration, const int buttonIndex, QObject *parent = nullptr);
-    ~MenuOverflowButton() override;
-
-    void paintIcon(QPainter *painter, const QRectF &iconRect, const qreal gridUnit) override;
-};
-
-} // namespace Material
diff --git a/src/TextButton.cc b/src/TextButton.cc
deleted file mode 100644
index 81a50e0..0000000
--- a/src/TextButton.cc
+++ /dev/null
@@ -1,130 +0,0 @@
-/*
- * Copyright (C) 2020 Chris Holland <zrenfire@gmail.com>
- * Copyright (C) 2016 Kai Uwe Broulik <kde@privat.broulik.de>
- * Copyright (C) 2014 by Hugo Pereira Da Costa <hugo.pereira@free.fr>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program. If not, see <http://www.gnu.org/licenses/>.
- */
-
-// own
-#include "TextButton.h"
-#include "Material.h"
-#include "AppMenuButton.h"
-#include "Decoration.h"
-
-// KDecoration
-#include <KDecoration2/DecoratedClient>
-#include <KDecoration2/DecorationSettings>
-
-// Qt
-#include <QDebug>
-#include <QAction>
-#include <QFontMetrics>
-#include <QPainter>
-
-
-namespace Material
-{
-
-TextButton::TextButton(Decoration *decoration, const int buttonIndex, QObject *parent)
-    : AppMenuButton(decoration, buttonIndex, parent)
-    , m_action(nullptr)
-    , m_text(QStringLiteral("Menu"))
-{
-    const auto *deco = qobject_cast<Decoration *>(decoration);
-
-    setHorzPadding(deco->appMenuButtonHorzPadding());
-
-    setVisible(true);
-}
-
-TextButton::~TextButton()
-{
-}
-
-void TextButton::paintIcon(QPainter *painter, const QRectF &iconRect, const qreal gridUnit)
-{
-    Q_UNUSED(iconRect)
-    Q_UNUSED(gridUnit)
-
-    // Font
-    painter->setFont(decoration()->settings()->font());
-
-    // TODO: Use Qt::TextShowMnemonic when Alt is pressed
-    const bool isAltPressed = false;
-    const Qt::TextFlag mnemonicFlag = isAltPressed ? Qt::TextShowMnemonic : Qt::TextHideMnemonic;
-    painter->drawText(geometry(), mnemonicFlag | Qt::AlignCenter, m_text);
-}
-
-QSize TextButton::getTextSize()
-{
-    const auto *deco = qobject_cast<Decoration *>(decoration());
-    if (!deco) {
-        return QSize(0, 0);
-    }
-
-    // const QString elidedText = painter->fontMetrics().elidedText(
-    //     m_text,
-    //     Qt::ElideRight,
-    //     100, // Max width TODO: scale by dpi
-    // );
-    const int textWidth = deco->getTextWidth(m_text);
-    const int titleBarHeight = deco->titleBarHeight();
-    const QSize size(textWidth, titleBarHeight);
-    return size;
-}
-
-QAction* TextButton::action() const
-{
-    return m_action;
-}
-
-void TextButton::setAction(QAction *set)
-{
-    if (m_action != set) {
-        m_action = set;
-        emit actionChanged();
-    }
-}
-
-QString TextButton::text() const
-{
-    return m_text;
-}
-
-void TextButton::setText(const QString set)
-{
-    if (m_text != set) {
-        m_text = set;
-        emit textChanged();
-
-        updateGeometry();
-    }
-}
-
-void TextButton::setHeight(int buttonHeight)
-{
-    Q_UNUSED(buttonHeight)
-
-    updateGeometry();
-}
-
-void TextButton::updateGeometry()
-{
-    const QSize textSize = getTextSize();
-    updateSize(textSize.width(), textSize.height());
-}
-
-
-} // namespace Material
diff --git a/src/TextButton.h b/src/TextButton.h
deleted file mode 100644
index 86299f2..0000000
--- a/src/TextButton.h
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright (C) 2020 Chris Holland <zrenfire@gmail.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program. If not, see <http://www.gnu.org/licenses/>.
- */
-
-#pragma once
-
-// own
-#include "AppMenuButton.h"
-
-// Qt
-#include <QAction>
-
-namespace Material
-{
-
-class Decoration;
-
-class TextButton : public AppMenuButton
-{
-    Q_OBJECT
-
-public:
-    TextButton(Decoration *decoration, const int buttonIndex, QObject *parent = nullptr);
-    ~TextButton() override;
-
-    Q_PROPERTY(QAction* action READ action WRITE setAction NOTIFY actionChanged)
-    Q_PROPERTY(QString text READ text WRITE setText NOTIFY textChanged)
-
-    void paintIcon(QPainter *painter, const QRectF &iconRect, const qreal gridUnit) override;
-    QSize getTextSize();
-
-
-    QAction* action() const;
-    void setAction(QAction *set);
-
-    QString text() const;
-    void setText(const QString set);
-
-    void setHeight(int buttonHeight) override;
-    void updateGeometry();
-
-signals:
-    void actionChanged();
-    void textChanged();
-
-private:
-    QAction *m_action;
-    QString m_text;
-};
-
-} // namespace Material
